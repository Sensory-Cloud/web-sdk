import { EnrollmentType, SDKInitConfig } from "../../src/config";
import { OauthService } from "../../src/services/oauth.service";
import { VideoService } from "../../src/services/video.service";
import { TokenManager } from "../../src/token-manager/token.manager";
import { VideoStreamInteractor } from "../../src/interactors/video-stream.interactor";
import { SecureCredentialStoreExample } from "./secure-credential-store.example";
import { AuthenticateRequest, CreateEnrollmentRequest, GetModelsResponse, ValidateRecognitionRequest } from "../../src/generated/v1/video/video_pb";
import { EnrollmentIdentifier, Initializer } from "../../src";

// Tenant ID granted by Sensory Inc.
const sensoryTenantId: string = 'f6580f3b-dcaf-465b-867e-59fbbb0ab3fc';
// Device enrollment credential configured in sensory cloud server
const credential: string = 'secure-password';
// Globally Unique device ID generated by you to pin the web-sdk to a browser.
const uniqueDeviceId: string = '337ed9ac-4c0f-4cd2-9ecc-51f712e53e92';

const config: SDKInitConfig = {
  fullyQualifiedDomainName: 'your-inference-server.com',
  isSecure: true,
  tenantId: sensoryTenantId,
  enrollmentType: EnrollmentType.sharedSecret,
  credential: credential,
  deviceId: uniqueDeviceId,
  deviceName: 'example-device'
}

// Implement your own secure credential store
const credentialStore = new SecureCredentialStoreExample();
const oauthService = new OauthService(credentialStore);
const tokenManager = new TokenManager(oauthService);

// Initialize the SDK
await Initializer.initializeFromConfig(config, oauthService);

// VideoStreamInteractor is a Sensory implementation that interacts with cameras through the web browser
const videoStreamInteractor = new VideoStreamInteractor();

const videoService = new VideoService(tokenManager, videoStreamInteractor);

const getVideoService = (): VideoService => {
  // Implement your own secure credential store
  const credentialStore = new SecureCredentialStoreExample();
  const oauthService = new OauthService(credentialStore);
  const tokenManager = new TokenManager(oauthService);

  // VideoStreamInteractor is a Sensory implementation that interacts with cameras through the web browser
  const videoStreamInteractor = new VideoStreamInteractor();

  return new VideoService(tokenManager, videoStreamInteractor);
}

const exampleGetVideoModels = (): Promise<GetModelsResponse.AsObject> => {
  const videoService = getVideoService();
  return videoService.getModels();
}

const exampleEnrollWithVideo = async () => {
  // Set basic enrollment information
  const enrollmentDescription = "My Enrollment";
  const userId = "72f286b8-173f-436a-8869-6f7887789ee9";
  const modelName = "face_biometric_hektor";
  const isLivenessEnabled = true;

  // Begin gRPC enrollment stream
  const enrollmentStream = await videoService.streamEnrollment(
    enrollmentDescription,
    userId,
    modelName,
    isLivenessEnabled);


  // Start camera recording
  const doCaptureFrame = await videoStreamInteractor.startCapturing();

  // Create callback to capture and send a frame up to Sensory Cloud
  const captureAndSendFrame = async () => {
    const frame = await doCaptureFrame();
    const request = new CreateEnrollmentRequest();
    request.setImagecontent(frame);

    try {
      enrollmentStream.write(request);
    } catch (err) {
      console.error(err);
    }
  }

  // enrollmentId will be populated on the very last message if enrollment is successful.
  let enrollmentId: string|null = null;

  // Handle responses from the server
  enrollmentStream.on('data', async (response) => {
    // Response contains information about the enrollment status.
    // * percentComplete

    // If enrollment is successful enrollmentId will be populated
    enrollmentId = response.getEnrollmentid();

    // If enrollment is not complete, send the next frame
    if (!enrollmentId) {
      await captureAndSendFrame();
    }
  });

  // Handle end of stream. This promise can be used to block until enrollment is complete.
  const streamEnd = new Promise<string>((resolve, reject) => {
    enrollmentStream.on('end', (status) => {
      videoStreamInteractor.stopCapturing();

      if (status?.code !== 0 || !enrollmentId?.length) {
        reject(`Enrollment failed due to reason: ${status?.details || 'enrollment was not complete'}`);
      } else {
        // Enrollment success!
        // Be sure to save enrollmentId for use later with authentication
        resolve(enrollmentId);
      }
    });
  });

  // Send first frame
  await captureAndSendFrame();

  return streamEnd;
}

const exampleAuthenticateWithVideo = async () => {
  // Set basic authentication information
  const enrollmentId = "72f286b8-173f-436a-8869-6f7887789ee9";
  const isLivenessEnabled = true;

  // Create the enrollment identifier, here we are authenticating against a single enrollment and not an enrollment group
  const enrollmentIdentifier: EnrollmentIdentifier = {enrollmentId: enrollmentId}

  // Begin gRPC authentication stream
  const authenticationStream = await videoService.streamAuthentication(
    enrollmentIdentifier,
    isLivenessEnabled);

  // Start camera recording
  const doCaptureFrame = await videoStreamInteractor.startCapturing();

  // Create callback to capture and send a frame up to Sensory Cloud
  const captureAndSendFrame = async () => {
    const frame = await doCaptureFrame();
    const request = new AuthenticateRequest();
    request.setImagecontent(frame);

    try {
      authenticationStream.write(request);
    } catch (err) {
      console.error(err);
    }
  }

  // isAuthenticated will be true on the very last message if auth is successful.
  let isAuthenticated = false;

  // Handle responses from the server
  authenticationStream.on('data', async (response) => {
    // isAuthenticated will be true on the very last message if auth is successful.
    isAuthenticated = response.getSuccess();
  });

  // Handle end of stream. This promise can be used to block until authentication is complete.
  const streamEnd = new Promise<boolean>((resolve, reject) => {
    authenticationStream.on('end', (status) => {
      videoStreamInteractor.stopCapturing();

      if (status?.code !== 0 || !isAuthenticated) {
        reject(`Authentication failed due to reason: ${status?.details || 'authentication was not successful'}`);
      } else {
        // Authentication success!
        // Be sure to save authenticationId for use later with authentication
        resolve(isAuthenticated);
      }
    });
  });

  // Send first frame
  await captureAndSendFrame();

  return streamEnd;
}

const exampleValidateLivenessWithVideo = async () => {
  // Set basic authentication information
  const userId = "72f286b8-173f-436a-8869-6f7887789ee9";
  const modelName = "face_recognition_mathilde"

  // Unlike enrollment and authentication, it is up to you, the implementer
  // to determine when to close the connection the server.
  const livenessStream = await videoService.streamLivenessRecognition(userId, modelName);

  // As an example, set a timeout for 10 seconds and then close the stream
  setTimeout(livenessStream.end, 10000);

  // Start camera recording
  const doCaptureFrame = await videoStreamInteractor.startCapturing();

  // Create callback to capture and send a frame up to Sensory Cloud
  const captureAndSendFrame = async () => {
    const frame = await doCaptureFrame();
    const request = new ValidateRecognitionRequest();
    request.setImagecontent(frame);

    try {
      livenessStream.write(request);
    } catch (err) {
      console.error(err);
    }
  }

  // isAlive tracks if the prior frame was live
  let isAlive = false;

  // Handle responses from the server
  livenessStream.on('data', async (response) => {
    // isAlive will be true if the prior frame was determined to be live.
    isAlive = response.getIsalive();

    // As an implementor you could end the stream after a single liveness detection here
    // or after multiple liveness frames if you'd like
    // via livenessStream.end
    await captureAndSendFrame();
  });

  // Handle end of stream. This promise can be used to block until liveness is complete.
  const streamEnd =  new Promise<boolean>((resolve, reject) => {
    livenessStream.on('end', (status) => {
      videoStreamInteractor.stopCapturing();

      if (status?.code !== 0) {
        reject(`Liveness failed due to reason: ${status?.details || 'liveness was not successful'}`);
      } else {
        // Liveness done!
        resolve(isAlive);
      }
    });
  });

  // Send first frame
  await captureAndSendFrame();

  return streamEnd;
}
